<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf8">
<title>Flawfinder Results</title>
<meta name="author" content="David A. Wheeler">
<meta name="keywords" lang="en" content="flawfinder results, security scan">
</head>
<body>
<h1>Flawfinder Results</h1>
Here are the security scan results from
<a href="https://dwheeler.com/flawfinder">Flawfinder version 2.0.17</a>,
(C) 2001-2019 <a href="https://dwheeler.com">David A. Wheeler</a>.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 222
<p>
Examining ./Security/Security/RecvImageTCP.cpp <br>
Examining ./Security/Security/CommandInterface.h <br>
Examining ./Security/Security/Security.h <br>
Examining ./Security/Security/CommandDecoder.h <br>
Examining ./Security/Security/resource.h <br>
Examining ./Security/Security/CommandEncoder.cpp <br>
Examining ./Security/Security/pch.h <br>
Examining ./Security/Security/RecvImageTCP.h <br>
Examining ./Security/Security/SecurityDlg.h <br>
Examining ./Security/Security/TcpSendRecvJpeg.h <br>
Examining ./Security/Security/Security.cpp <br>
Examining ./Security/Security/SecurityDlg.cpp <br>
Examining ./Security/Security/NetworkTCP.cpp <br>
Examining ./Security/Security/framework.h <br>
Examining ./Security/Security/NetworkTLS.h <br>
Examining ./Security/Security/NetworkTCP.h <br>
Examining ./Security/Security/NetworkTLS.cpp <br>
Examining ./Security/Security/pch.cpp <br>
Examining ./Security/Security/TcpSendRecvJpeg.cpp <br>
Examining ./Security/Security/CommandEncoder.h <br>
Examining ./Security/Security/targetver.h <br>
Examining ./Security/Security/CommandDecoder.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/CMakeFiles/feature_tests.c <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/CMakeFiles/feature_tests.cxx <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/CMakeFiles/3.10.2/CompilerIdC/CMakeCCompilerId.c <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/CMakeFiles/3.10.2/CompilerIdCXX/CMakeCXXCompilerId.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/build/CMakeFiles/feature_tests.c <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/build/CMakeFiles/feature_tests.cxx <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/build/CMakeFiles/3.10.2/CompilerIdC/CMakeCCompilerId.c <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/build/CMakeFiles/3.10.2/CompilerIdCXX/CMakeCXXCompilerId.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/pnet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/pBox.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/common.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/network.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/mtcnn.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/rnet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/baseEngine.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/onet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/demo.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/network.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/pnet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/common.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/baseEngine.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/rnet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/mtcnn.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/onet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/gssSocket.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/pnet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandInterface.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/pBox.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandDecoder.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mode_testrun.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/faceNet.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandEncoder.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/common.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/main.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/sslManager.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/videoStreamer.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/network.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/gssSocket.hpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/TcpSendRecvJpeg.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/Util.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/Logger.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mtcnn.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/videoStreamer.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/rnet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/sslManager.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/baseEngine.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/NetworkTCP.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mode.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/onet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/NetworkTCP.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/checkCmdArg.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/network.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/pnet_rt.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/common.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mode_learn.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/TcpSendRecvJpeg.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mode_run.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandEncoder.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/baseEngine.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.h <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/rnet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/mtcnn.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/onet_rt.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandDecoder.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/Logger.cpp <br>
Examining ./LgFaceRecDemoTCP_Jetson_NanoV2/src/faceNet.cpp <br>
Examining ./build/CMakeFiles/3.19.8/CompilerIdC/CMakeCCompilerId.c <br>
Examining ./build/CMakeFiles/3.19.8/CompilerIdCXX/CMakeCXXCompilerId.cpp <br>

<h2>Final Results</h2>
<ul>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/Logger.cpp:35: <b>  [4] </b> (format) <i> vprintf:
  If format strings can be influenced by an attacker, they can be exploited
  (<a href="https://cwe.mitre.org/data/definitions/134.html">CWE-134</a>).
  Use a constant for the format specification. </i>
<pre>
    nLength = vprintf(format, args) + 1;
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/Logger.cpp:39: <b>  [4] </b> (format) <i> vsnprintf:
  If format strings can be influenced by an attacker, they can be exploited,
  and note that sprintf variations do not always \0-terminate (<a
  href="https://cwe.mitre.org/data/definitions/134.html">CWE-134</a>). Use a
  constant for the format specification. </i>
<pre>
    vsnprintf(sMessage, nLength, format, args);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.cpp:51: <b>  [4] </b> (race) <i> access:
  This usually indicates a security flaw. If an attacker can change anything
  along the path between the call to access() and the file's actual use
  (e.g., by moving files), the attacker can exploit the race condition (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>/<a
  href="https://cwe.mitre.org/data/definitions/367.html">CWE-367</a>!). Set
  up the correct permissions (e.g., using setuid()) and try to open the file
  directly. </i>
<pre>
bool authenticateUser(unsigned char *idBuf, int idBufLen, unsigned char *pwdBuf, int pwdBufLen, AccessRight&amp; access)
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.cpp:65: <b>  [4] </b> (race) <i> access:
  This usually indicates a security flaw. If an attacker can change anything
  along the path between the call to access() and the file's actual use
  (e.g., by moving files), the attacker can exploit the race condition (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>/<a
  href="https://cwe.mitre.org/data/definitions/367.html">CWE-367</a>!). Set
  up the correct permissions (e.g., using setuid()) and try to open the file
  directly. </i>
<pre>
        bool result = auth.validateUser(id, pwd, access);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.cpp:125: <b>  [4] </b> (race) <i> access:
  This usually indicates a security flaw. If an attacker can change anything
  along the path between the call to access() and the file's actual use
  (e.g., by moving files), the attacker can exploit the race condition (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>/<a
  href="https://cwe.mitre.org/data/definitions/367.html">CWE-367</a>!). Set
  up the correct permissions (e.g., using setuid()) and try to open the file
  directly. </i>
<pre>
bool Authenticator::validateUser(string user_id, string user_pwd, AccessRight&amp; access)
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/mtcnn.cpp:113: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
                memcpy(it-&gt;regreCoord, refineNet-&gt;location_-&gt;pdata, 4*sizeof(mydataFmt));
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/mtcnn.cpp:145: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
                memcpy(it-&gt;regreCoord, outNet-&gt;location_-&gt;pdata, 4*sizeof(mydataFmt));
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/pnet_rt.cpp:24: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    protofile.open(prototxt, ios::in);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/pnet_rt.cpp:40: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    protofile.open("temp.prototxt", ios::out);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandDecoder.cpp:44: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(*buf, ptr, bufLen);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/CommandEncoder.cpp:53: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(ptr, sendbuff.data(), sendbuff.size());
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/Logger.cpp:20: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
        m_Logfile.open(m_sFileName.c_str(), ios::out | ios::app);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/Util.h:15: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
        char       buf[80];
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.h:21: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char salt[16];
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.h:61: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
        const unsigned char m_systemSalt[16] = {0x62, 0xA4, 0x66, 0x5E, 0x21, 0xEB, 0xA1, 0x40,
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/baseEngine.cpp:92: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
        planFile.open(enginePath);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/checkCmdArg.cpp:22: <b>  [2] </b> (integer) <i> atoi:
  Unless checked, the resulting number can exceed the expected range (<a
  href="https://cwe.mitre.org/data/definitions/190.html">CWE-190</a>). If
  source untrusted, check both minimum and maximum, even if the input had no
  minus sign (large numbers can roll over into negative number; consider
  saving to an unsigned value if that is intended). </i>
<pre>
    portNum     = atoi(argv[1]);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/common.cpp:99: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    char name_buf[128] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/common.cpp:133: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
        if((f = open(sFileName, O_RDONLY)) &lt; 0) throw (sFileName);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:5: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
unsigned char key[AES256_KEY_SIZE] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:52: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
        char temp[3] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:53: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
        memcpy(temp, str + i*2, 2);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:84: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char encrypted_filename_buf[128] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:96: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char iv_rand[AESCBC_IV_LENGTH] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:177: <b>  [2] </b> (misc) <i> fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    des_fptr = fopen(des_path, "wb");
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:227: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char encrypted_filename_buf[128] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:238: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char iv_rand[AESCBC_IV_LENGTH] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:262: <b>  [2] </b> (misc) <i> fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    src_fptr = fopen(src_path, "rb");
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:360: <b>  [2] </b> (misc) <i> fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    des_fptr = fopen(des_path, "wb");
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:397: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char iv[AESCBC_IV_LENGTH] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:406: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char encrypted_filename_buf[128] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:409: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char decrypted_filename_buf[128] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:422: <b>  [2] </b> (misc) <i> fopen:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    src_fptr = fopen(src_path, "rb");
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:456: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(iv, file_buf, AESCBC_IV_LENGTH);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:479: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
    memcpy(img_buf, decrypted_buf, decryptedtext_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:647: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char digest[outputBytes];
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:655: <b>  [2] </b> (buffer) <i> sprintf:
  Does not check for buffer overflows (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Use
  sprintf_s, snprintf, or vsnprintf. Risk is low because the source has a
  constant maximum length. </i>
<pre>
        sprintf(hexResult + (i * 2), "%02x", 255 &amp; digest[i]);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:662: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    const unsigned char salt[PBKDF2_SALT_LEN] = {0xC0, 0x62, 0x9F, 0x6C, 0xA4, 0x69, 0x43, 0xDE,
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:665: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    char out_hexstr[AES256_KEY_SIZE * 2 + 1] = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/faceNet.cpp:93: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
            planFile.open(m_engineFile);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/main.cpp:159: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
    unsigned char recvBuf[1000], sendBuf[1000];
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/mtcnn.cpp:125: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
                memcpy(it-&gt;regreCoord, refineNet-&gt;location_-&gt;pdata, 4*sizeof(mydataFmt));
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/mtcnn.cpp:157: <b>  [2] </b> (buffer) <i> memcpy:
  Does not check for buffer overflows when copying to destination (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). Make
  sure destination can always hold the source data. </i>
<pre>
                memcpy(it-&gt;regreCoord, outNet-&gt;location_-&gt;pdata, 4*sizeof(mydataFmt));
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/pnet_rt.cpp:24: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    protofile.open(prototxt, ios::in);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/pnet_rt.cpp:41: <b>  [2] </b> (misc) <i> open:
  Check when opening files - can an attacker redirect it (via symlinks),
  force the opening of special file type (e.g., device files), move things
  around to create a race condition, control its ancestors, or change its
  contents? (<a
  href="https://cwe.mitre.org/data/definitions/362.html">CWE-362</a>). </i>
<pre>
    protofile.open("temp.prototxt", ios::out);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/sslManager.cpp:9: <b>  [2] </b> (buffer) <i> char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (<a
  href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>!/<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Perform bounds checking, use functions that limit length, or ensure that
  the size is larger than the maximum possible length. </i>
<pre>
char sslManager_buf[SSL_BUF_SIZE]       = {0, };
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/MTCNN_FaceDetection_TensorRT/src/common.cpp:36: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    infile.read(reinterpret_cast&lt;char*&gt;(buffer), inH*inW);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/authenticator.cpp:43: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
        strncpy(sslManager_buf, passphrase.c_str(), sslManager_buf_size);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/baseEngine.cpp:55: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
            file.read(trtModelStream_.data(), size);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:173: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
    strncpy(des_path, dir_path, dir_path_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:174: <b>  [1] </b> (buffer) <i> strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Consider strcat_s, strlcat, snprintf, or automatically resizing strings. </i>
<pre>
    strncat(des_path, des_filename, des_filename_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:257: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
    strncpy(src_path, dir_path, dir_path_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:258: <b>  [1] </b> (buffer) <i> strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Consider strcat_s, strlcat, snprintf, or automatically resizing strings. </i>
<pre>
    strncat(src_path, filename, filename_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:356: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
    strncpy(des_path, dir_path, dir_path_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:357: <b>  [1] </b> (buffer) <i> strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>).
  Consider strcat_s, strlcat, snprintf, or automatically resizing strings. </i>
<pre>
    strncat(des_path, des_filename, des_filename_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:485: <b>  [1] </b> (buffer) <i> strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (<a
  href="https://cwe.mitre.org/data/definitions/126.html">CWE-126</a>). </i>
<pre>
    filename_len = strlen(filename);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/crypto_op.cpp:509: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
    strncpy(name_buf, (char*)decrypted_filename_buf, decrypted_filename_len);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/faceNet.cpp:44: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
            file.read(trtModelStream_.data(), size);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/main.cpp:46: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    if ((r = read(0, &amp;c, sizeof(c))) &lt; 0) {
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/main.cpp:80: <b>  [1] </b> (buffer) <i> strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (<a
  href="https://cwe.mitre.org/data/definitions/126.html">CWE-126</a>). </i>
<pre>
    int idBufLen    = strlen((char *)idBuf);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/main.cpp:81: <b>  [1] </b> (buffer) <i> strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (<a
  href="https://cwe.mitre.org/data/definitions/126.html">CWE-126</a>). </i>
<pre>
    int pwdBufLen   = strlen((char *)pwdBuf);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/sslManager.cpp:22: <b>  [1] </b> (buffer) <i> strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>). </i>
<pre>
    strncpy(buf, sslManager_buf, size);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/src/sslManager.cpp:25: <b>  [1] </b> (buffer) <i> strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (<a
  href="https://cwe.mitre.org/data/definitions/126.html">CWE-126</a>). </i>
<pre>
    return(strlen(buf));
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:27: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    op_type  = read&lt;int&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:28: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    eps = read&lt;float&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:29: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    C = read&lt;int&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:30: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    H = read&lt;int&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:31: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    W = read&lt;int&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.cpp:32: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
    mDataType = read&lt;DataType&gt;(d);
</pre>
<li>./LgFaceRecDemoTCP_Jetson_NanoV2/trt_l2norm_helper/l2norm_helper.h:126: <b>  [1] </b> (buffer) <i> read:
  Check buffer boundaries if used in a loop including recursive loops (<a
  href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>, <a
  href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>). </i>
<pre>
T read(const char*&amp; buffer)
</pre>
</ul>
<h2>Analysis Summary</h2>
<p>
Hits = 70
<br>
Lines analyzed = 13555 in approximately 0.13 seconds (106361 lines/second)
<br>
Physical Source Lines of Code (SLOC) = 10142
<br>
Hits@level = [0]  79 [1]  24 [2]  41 [3]   0 [4]   5 [5]   0 <br>
Hits@level+ = [0+] 149 [1+]  70 [2+]  46 [3+]   5 [4+]   5 [5+]   0 <br>
Hits/KSLOC@level+ = [0+] 14.6914 [1+] 6.90199 [2+] 4.53559 [3+] 0.492999 [4+] 0.492999 [5+]   0 <br>
Dot directories skipped = 2 (--followdotdir overrides)
<br>
Minimum risk level = 1
<br>
Not every hit is necessarily a security vulnerability.
You can inhibit a report by adding a comment in this form:
// flawfinder: ignore
Make *sure* it's a false positive!
You can use the option --neverignore to show these.
<br>
There may be other security vulnerabilities; review your code!
<br>
See '<a href="https://dwheeler.com/secure-programs">Secure Programming HOWTO</a>'
(<a href="https://dwheeler.com/secure-programs">https://dwheeler.com/secure-programs</a>) for more information.
</body>
</html>
